import dotenv from 'dotenv';
import { EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, MessageFlags, AttachmentBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, ButtonBuilder, ButtonStyle } from 'discord.js';
import axios from 'axios';
import QRCode from 'qrcode';
import fs from 'fs';
import { storePendingPayment } from './webhook.mjs';
import { PushinpayApiService } from './services/pushinpay.mjs';

dotenv.config();

const ADMIN_ID = process.env.ADMIN_ID;
const pixCodeTemp = {};
const WEBHOOK_URL = process.env.PAYMENT_WEBHOOK_URL || null;
const ICON_URL = 'https://media.discordapp.net/attachments/1381455221439336538/1396935134036365322/1381486372543529031.png?ex=687fe4b9&is=687e9339&hm=90a20842b9e0ca1372db14b166f183e88f09210bb0b59265594cc58719becbd4&=&format=webp&quality=lossless';
const STORE_NAME = 'Reprovacao - Store';

const produtos = [
    { 
    id: 'fruta112', 
    nome: ' 5000 ROBUX', 
    preco: 19.90, 
    estoque: 3, 
    emoji: '1407870790233489479',
    originalPrice: 34.00,
    rarity: 'UNICA',
    power: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê',
    description: 'Compre com seguran√ßa somente aqui!'
  },
  { 
    id: 'fruta122', 
    nome: '7200 ROBUX', 
    preco: 32.90, 
    estoque: 3, 
    emoji: '1407870790233489479',
    originalPrice: 90.00,
    rarity: 'UNICO',
    power: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê',
    description: 'Compre com seguran√ßa somente aqui!'
  },
  { 
    id: 'fruta1223', 
    nome: '8500 ROBUX', 
    preco: 42.90, 
    estoque: 1, 
    emoji: '1407870790233489479',
    originalPrice: 85.00,
    rarity: 'UNICO',
    power: '‚≠ê‚≠ê‚≠ê‚≠ê',
    description: 'Compre com seguran√ßa somente aqui!'
  }
];

// Professional color schemes
const COLORS = {
  primary: '#1e40af',
  success: '#059669',
  warning: '#d97706',
  danger: '#dc2626',
  gold: '#f59e0b',
  premium: '#7c3aed',
  processing: '#8b5cf6',
  mythic: '#e11d48',
  legendary: '#7c2d12',
  epic: '#9333ea',
  rare: '#2563eb'
};

const getRarityColor = (rarity) => {
  switch(rarity) {
    case 'M√≠tica': return COLORS.mythic;
    case 'Lend√°ria': return COLORS.legendary;
    case '√âpica': return COLORS.epic;
    case 'Rara': return COLORS.rare;
    default: return COLORS.primary;
  }
};

async function simulateRobloxVerification(interaction, username, produto) {
  try {
    // Step 1: Enhanced processing display
    const step1Embed = new EmbedBuilder()
      .setTitle('üîç **Verifica√ß√£o de Seguran√ßa Iniciada**')
      .setDescription(
        `**üéØ Usu√°rio:** \`${username}\`\n` +
        `**üçé Produto:** ${produto.nome}\n` +
        `**üíé Raridade:** ${produto.rarity}\n\n` +
        `‚ö° **Iniciando protocolos de seguran√ßa...**\n` +
        `üîê **Sistema anti-fraude ativo**`
      )
      .setColor(COLORS.processing)
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üõ°Ô∏è Status', value: '```‚è≥ Verificando credenciais```', inline: true },
        { name: '‚ö° Tempo Estimado', value: '```üïê 5-8 segundos```', inline: true },
        { name: 'üîí Seguran√ßa', value: '```üü¢ M√°xima Prote√ß√£o```', inline: true }
      )
      .setFooter({ text: `üîí Verifica√ß√£o Segura | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    await interaction.editReply({ embeds: [step1Embed] });
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Step 2: API Connection
    const step2Embed = new EmbedBuilder()
      .setTitle('üì° **Conectando √† API Oficial do Roblox**')
      .setDescription(
        `**üîÑ Estabelecendo conex√£o segura...**\n` +
        `**üåê Validando usu√°rio na base oficial**\n` +
        `**üõ°Ô∏è Verificando elegibilidade para pets**\n\n` +
        `‚ú® **Tecnologia de ponta para m√°xima seguran√ßa**`
      )
      .setColor(COLORS.warning)
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üìä Sistema', value: '```üü° API Roblox Oficial```', inline: true },
        { name: 'üîê Conex√£o', value: '```üü° SSL Certificado```', inline: true },
        { name: 'üçé Grow a garden', value: '```üü° Verificando Jogo```', inline: true }
      )
      .setFooter({ text: `üåü Tecnologia Premium | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    await interaction.editReply({ embeds: [step2Embed] });
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Get real user data from Roblox API
    let userData = null;
    try {
      const userSearchResponse = await axios.post('https://users.roblox.com/v1/usernames/users', {
        usernames: [username]
      });

      if (userSearchResponse.data.data && userSearchResponse.data.data.length > 0) {
        const userId = userSearchResponse.data.data[0].id;
        const userDetailsResponse = await axios.get(`https://users.roblox.com/v1/users/${userId}`);
        userData = userDetailsResponse.data;
      }
    } catch (apiError) {
      console.error('‚ùå Erro ao consultar API do Roblox:', apiError.message);
    }

    if (!userData) {
      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå **Usu√°rio N√£o Encontrado**')
        .setDescription(
          `**O usu√°rio \`${username}\` n√£o foi localizado.**\n\n` +
          `üìù **Dicas para resolver:**\n` +
          `‚Ä¢ Verifique se o nome est√° **exatamente** correto\n` +
          `‚Ä¢ Certifique-se de usar o **username**, n√£o o display name\n` +
          `‚Ä¢ Certifique-se de ter o Blox Fruits no perfil\n` +
          `‚Ä¢ Tente novamente em alguns segundos\n\n` +
          `üí° **Precisa de ajuda?** Nossa equipe est√° dispon√≠vel 24/7!`
        )
        .setColor(COLORS.danger)
        .setThumbnail(ICON_URL)
        .setFooter({ text: `üÜò Suporte 24/7 | ${STORE_NAME}`, iconURL: ICON_URL })
        .setTimestamp();

      await interaction.editReply({ embeds: [errorEmbed] });
      return;
    }

    // Step 3: User verification success
    const accountCreated = new Date(userData.created);
    const accountAge = Math.floor((Date.now() - accountCreated.getTime()) / (1000 * 60 * 60 * 24));
    
    const step3Embed = new EmbedBuilder()
      .setTitle('‚úÖ **Usu√°rio Verificado com Sucesso!**')
      .setDescription(
        `**üéâ Conta Roblox encontrada e qualificada!**\n\n` +
        `**üìä Informa√ß√µes da Conta:**`
      )
      .setColor(COLORS.success)
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üë§ Nome do Usu√°rio', value: `\`\`\`${userData.displayName || userData.name}\`\`\``, inline: true },
        { name: 'üÜî ID da Conta', value: `\`\`\`${userData.id}\`\`\``, inline: true },
        { name: 'üìÖ Conta Criada', value: `\`\`\`${accountCreated.toLocaleDateString('pt-BR')}\`\`\``, inline: true },
        { name: '‚è∞ Idade da Conta', value: `\`\`\`${accountAge} dias\`\`\``, inline: true },
        { name: 'üéÆ Status BloxFruits', value: `\`\`\`‚úÖ Qualificado\`\`\``, inline: true },
        { name: 'üõ°Ô∏è Verifica√ß√£o', value: `\`\`\`üü¢ Aprovada\`\`\``, inline: true }
      )
      .setFooter({ text: `‚úÖ Verifica√ß√£o Conclu√≠da | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    await interaction.editReply({ embeds: [step3Embed] });
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Step 4: Security validation
    const step4Embed = new EmbedBuilder()
      .setTitle('üîê **Verifica√ß√µes de Seguran√ßa Avan√ßadas**')
      .setDescription(
        `**üõ°Ô∏è Executando protocolos de seguran√ßa para pets...**\n\n` +
        `**Todas as verifica√ß√µes foram aprovadas com sucesso!**`
      )
      .setColor(COLORS.success)
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üîç Anti-Fraude', value: '```‚úÖ APROVADO```', inline: true },
        { name: 'üéÆ Jogo Ativo', value: '```‚úÖ GROW A GARDEN```', inline: true },
        { name: 'üö´ Restri√ß√µes', value: '```‚úÖ NENHUMA```', inline: true },
        { name: 'üíé Elegibilidade', value: '```‚úÖ QUALIFICADO```', inline: true },
        { name: 'üçé Tipo', value: '```‚úÖ PERMANENTE```', inline: true },
        { name: '‚ö° Processo', value: '```‚úÖ FINALIZADO```', inline: true }
      )
      .setFooter({ text: `üõ°Ô∏è M√°xima Seguran√ßa | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    await interaction.editReply({ embeds: [step4Embed] });
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Step 5: Final confirmation with product details
    const savings = produto.originalPrice - produto.preco;
    const discountPercent = Math.round((savings / produto.originalPrice) * 100);
    
    const step5Embed = new EmbedBuilder()
      .setTitle('üéâ **Verifica√ß√£o Conclu√≠da - Pronto para Pagamento!**')
      .setDescription(
        `**üåü Parab√©ns! Sua conta foi verificada com sucesso!**\n\n` +
        `**üçé Resumo da sua compra:**`
      )
      .setColor(getRarityColor(produto.rarity))
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üë§ Usu√°rio Roblox', value: `\`\`\`${username}\`\`\``, inline: true },
        { name: 'üçé Robux', value: `\`\`\`${produto.nome}\`\`\``, inline: true },
        { name: 'üíé Raridade', value: `\`\`\`${produto.rarity}\`\`\``, inline: true },
        { name: '‚≠ê Poder', value: `\`\`\`${produto.power}\`\`\``, inline: true },
        { name: 'üí∞ Pre√ßo Final', value: `\`\`\`R$ ${produto.preco.toFixed(2)}\`\`\``, inline: true },
        { name: 'üí∏ Economia', value: `\`\`\`R$ ${savings.toFixed(2)} (${discountPercent}% OFF)\`\`\``, inline: true }
      )
      .setFooter({ text: `üîÑ Gerando pagamento PIX... | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    await interaction.editReply({ embeds: [step5Embed] });
    await new Promise(resolve => setTimeout(resolve, 1500));

    await gerarPagamento(interaction, produto, username);

  } catch (error) {
    console.error('‚ùå Erro na verifica√ß√£o:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ö†Ô∏è **Erro Tempor√°rio do Sistema**')
      .setDescription(
        `**Ops! Encontramos um problema t√©cnico.**\n\n` +
        `üîß **O que fazer:**\n` +
        `‚Ä¢ Tente novamente em alguns segundos\n` +
        `‚Ä¢ Verifique sua conex√£o com a internet\n` +
        `‚Ä¢ Entre em contato com nossa equipe se persistir\n\n` +
        `üÜò **Suporte 24/7 dispon√≠vel para ajudar!**`
      )
      .setColor(COLORS.danger)
      .setThumbnail(ICON_URL)
      .setFooter({ text: `üõ†Ô∏è Suporte T√©cnico | ${STORE_NAME}`, iconURL: ICON_URL })
      .setTimestamp();

    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    } else {
      await interaction.editReply({ embeds: [errorEmbed] }).catch(console.error);
    }
  }
}

async function gerarPagamento(interaction, produto, username = null) {
  try {
    console.log(`üîó Iniciando cria√ß√£o de pagamento PIX via Pushi-In Pay...`);

    // Create Pushi-In Pay payment request - value in cents
    const valueInCents = Math.max(50, Math.round(produto.preco * 100)); // Ensure minimum 50 cents
    const customerData = {
      name: username || process.env.CUSTOMER_NAME || 'Usu√°rio Roblox',
      email: process.env.CUSTOMER_EMAIL || 'avariarbux@discord.com',
      cpf: process.env.CUSTOMER_CPF || '12151185460',
      phone: process.env.CUSTOMER_PHONE || '98981557066',
      paymentMethod: 'PIX',
      amount: valueInCents, // Value in cents (minimum 50)
      traceable: true,
      items: [{ 
        title: produto.nome,
        quantity: 1, 
        unitPrice: valueInCents,
        tangible: false
      }],
      externalId: `pet_${Date.now()}`
    };

    const pushinpayApi = new PushinpayApiService();
    const paymentData = await pushinpayApi.createPixPayment(customerData);
    
    const pixCode = paymentData.pixCode;
    pixCodeTemp[interaction.user.id] = pixCode;
    const paymentId = paymentData.id;
    const qrPath = `./qrcodes/${produto.id}_${paymentId}.png`;
    
    if (!fs.existsSync('./qrcodes')) {
      fs.mkdirSync('./qrcodes');
    }
    
    await QRCode.toFile(qrPath, pixCode);

    storePendingPayment(paymentId, {
      produto,
      username,
      userId: interaction.user.id,
      channelId: interaction.channelId,
      guildId: interaction.guildId,
      value: produto.preco,
      pixCode,
      interaction: interaction, // Store interaction for ephemeral responses
      createdAt: new Date().toISOString()
    });

    const embedPagamento = new EmbedBuilder()
      .setTitle('üßæ **PIX Gerado - Finalize e Receba seu pet!**')
      .setDescription(
        `**üéØ √öltima etapa para receber sua ${produto.nome}!**\n\n` +
        `**üí≥ Informa√ß√µes do Pagamento:**\n` +
        `üçé **moeda:** ${produto.nome} (${produto.rarity})\n` +
        `üí∞ **Valor:** R$ ${produto.preco.toFixed(2)}\n` +
        `üë§ **Usu√°rio:** \`${username}\`\n` +
        `üÜî **ID Pagamento:** \`${paymentId}\`\n` +
        `‚è±Ô∏è **Validade:** 30 minutos\n\n` +
        `**üì± Como pagar:**\n` +
        `1Ô∏è‚É£ Abra seu app banc√°rio\n` +
        `2Ô∏è‚É£ Escolha "PIX Copia e Cola"\n` +
        `3Ô∏è‚É£ Cole o c√≥digo abaixo\n` +
        `4Ô∏è‚É£ Confirme o pagamento\n\n` +
        `**üîó C√≥digo PIX:**`
      )
      .setColor(getRarityColor(produto.rarity))
      .setThumbnail(ICON_URL)
      .addFields(
        { name: 'üìã Copia e Cola', value: `\`\`\`${pixCode}\`\`\``, inline: false },
        { name: '‚ö° Processamento', value: '```üöÄ Autom√°tico e Instant√¢neo```', inline: true },
        { name: 'üîí Seguran√ßa', value: '```üõ°Ô∏è Pagamento 100% Seguro```', inline: true },
        { name: 'üçé Status', value: '```‚è≥ Aguardando Pagamento```', inline: true }
      )
      .setFooter({ text: 'üíé Entrega autom√°tica ap√≥s confirma√ß√£o | Guaxinim Store', iconURL: ICON_URL })
      .setTimestamp();

    // No manual verification buttons to avoid API spam

    const qrAttachment = new AttachmentBuilder(qrPath);

    const row = new ActionRowBuilder().addComponents(
  new ButtonBuilder()
    .setCustomId('copiar_pix')
    .setLabel('üìã Copiar C√≥digo PIX')
    .setStyle(ButtonStyle.Primary)
);

await interaction.editReply({ 
  embeds: [embedPagamento], 
  components: [row],
  files: [qrAttachment]
});


    console.log(`üíæ Pagamento ${paymentId} criado para ${username} - ${produto.nome}`);

  } catch (error) {
    console.error('‚ùå Erro ao gerar Pix:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ö†Ô∏è **Erro ao Gerar Pagamento**')
      .setDescription(
        `**N√£o foi poss√≠vel gerar o PIX no momento.**\n\n` +
        `üîß **Tente novamente em alguns instantes.**\n` +
        `üÜò **Se o problema persistir, contate nosso suporte!**`
      )
      .setColor(COLORS.danger)
      .setFooter({ text: 'üõ†Ô∏è Suporte T√©cnico 24/7 | Guaxinim Store', iconURL: ICON_URL });

    await interaction.editReply({ embeds: [errorEmbed] }).catch(console.error);
  }
}

export default function setupLoja(client) {
  client.on('messageCreate', async (message) => {
    if (message.author.bot) return;

    // Command: !loja
    if (message.content.toLowerCase() === '!lojarobux') {
      const embed = new EmbedBuilder()
        .setTitle('üçé **LOJA DE ROBUX - ROBLOX**')
        .setDescription(
          `**üåü Bem-vindo √† nossa loja premium!**\n\n` +
          `**üî• Ofertas Especiais:**\n` +
          `‚Ä¢ **pets 100% Permanentes**\n` +
          `‚Ä¢ **Entrega Autom√°tica** em at√© 5 minutos\n` +
          `‚Ä¢ **Pre√ßos Exclusivos** com at√© 60% OFF\n` +
          `‚Ä¢ **Suporte 24/7** sempre dispon√≠vel\n` +
          `‚Ä¢ **Garantia Total** ou seu dinheiro de volta\n\n` +
          `**üì¶ Selecione seus pets abaixo:**`
        )
        .setColor(COLORS.gold)
        .setThumbnail(ICON_URL)
        .setImage('https://media.discordapp.net/attachments/1381455217912189050/1411126559925862511/Banner_Roblox_5000_Robux_Preco_Novo.png?ex=68b38585&is=68b23405&hm=caee09530f85a22953a8526f70d05bb489be082a15510fb14091e8fbff0ec4d3&=&format=webp&quality=lossless')
        .addFields(
          { name: 'üî• Destaque', value: 'Todos os ROBUX s√£o **PERMANENTES**', inline: true },
          { name: '‚ö° Entrega', value: '**Autom√°tica e Imediata**', inline: true },
          { name: 'üõ°Ô∏è Garantia', value: '**100% Seguro**', inline: true }
        )
        .setFooter({ text: `üõí Loja Premium | ${STORE_NAME}`, iconURL: ICON_URL })
        .setTimestamp();

      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('select_fruta')
        .setPlaceholder('üçé Escolha a quantia de ROBUX...')
        .addOptions(
          produtos.map(produto => {
            const savings = produto.originalPrice - produto.preco;
            const discountPercent = Math.round((savings / produto.originalPrice) * 100);
            
            return {
              label: `${produto.nome} - R$ ${produto.preco.toFixed(2)}`,
              description: `${produto.rarity} ‚Ä¢ ${discountPercent}% OFF ‚Ä¢ Estoque: ${produto.estoque}`,
              value: produto.id,
              emoji: produto.emoji
            };
          })
        );

      const row = new ActionRowBuilder().addComponents(selectMenu);

      await message.reply({ embeds: [embed], components: [row] });
    }
  });

  // Handle select menu interactions
  client.on('interactionCreate', async (interaction) => {
    if (!interaction.isStringSelectMenu()) return;

    if (interaction.customId === 'select_fruta') {
      const produtoId = interaction.values[0];
      const produto = produtos.find(p => p.id === produtoId);

      if (!produto) return;

      if (produto.estoque <= 0) {
        const estoqueEmbed = new EmbedBuilder()
          .setTitle('‚ùå **Produto Esgotado**')
          .setDescription('**Desculpe! Esta pet est√° temporariamente esgotada.**\n\nTente novamente mais tarde ou escolha outra pet.')
          .setColor(COLORS.danger)
          .setThumbnail(ICON_URL)
          .setFooter({ text: `üõí Loja Online | ${STORE_NAME}`, iconURL: ICON_URL })
          .setTimestamp();

        return interaction.reply({ embeds: [estoqueEmbed], flags: MessageFlags.Ephemeral });
      }

      const savings = produto.originalPrice - produto.preco;
      const discountPercent = Math.round((savings / produto.originalPrice) * 100);

      const embed = new EmbedBuilder()
        .setTitle(`${produto.emoji} **${produto.nome}**`)
        .setDescription(
          `**${produto.description}**\n\n` +
          `**üìä Detalhes da moeda:**\n` +
          `üíé **Raridade:** ${produto.rarity}\n` +
          `‚≠ê **Poder:** ${produto.power}\n` +
          `üî• **Tipo:** moeda Permanente\n` +
          `üì¶ **Estoque:** ${produto.estoque} unidade(s)\n\n` +
          `**üí∏ Economia incr√≠vel de R$ ${savings.toFixed(2)} (${discountPercent}% OFF)**`
        )
        .setColor(getRarityColor(produto.rarity))
        .setThumbnail(ICON_URL)
        .addFields(
          { name: 'üí∞ Pre√ßo Promocional', value: `**R$ ${produto.preco.toFixed(2)}**`, inline: true },
          { name: 'üè∑Ô∏è Pre√ßo Normal', value: `~~R$ ${produto.originalPrice.toFixed(2)}~~`, inline: true },
          { name: '‚ö° Entrega', value: '**Autom√°tica e Imediata**', inline: true },
          { name: 'üõ°Ô∏è Garantia', value: '**100% Seguro**', inline: true },
          { name: 'üéØ M√©todo', value: '**PIX Instant√¢neo**', inline: true },
          { name: 'üîí Seguran√ßa', value: '**M√°xima Prote√ß√£o**', inline: true }
        )
        .setFooter({ text: `üçé Robux Permanente | ${STORE_NAME}`, iconURL: ICON_URL })
        .setTimestamp();

      const button = new ButtonBuilder()
        .setCustomId(`comprar_${produto.id}`)
        .setLabel('üõí COMPRAR AGORA')
        .setStyle(ButtonStyle.Success)
        .setEmoji(produto.emoji);

      const row = new ActionRowBuilder().addComponents(button);

      await interaction.reply({ embeds: [embed], components: [row], flags: MessageFlags.Ephemeral });
    }
  });

  // Handle button interactions for fruits
  client.on('interactionCreate', async (interaction) => {
    if (!interaction.isButton()) return;
    
      if (interaction.customId === 'copiar_pix') {
    const code = pixCodeTemp[interaction.user.id];

    if (!code) {
      return await interaction.reply({
        content: '‚ùå C√≥digo PIX n√£o encontrado ou expirado.',
        ephemeral: true
      });
    }

    return await interaction.reply({
      content: `${code}`,
      ephemeral: true
    });
  }


    if (interaction.customId.startsWith('comprar_fruta')) {
      const produtoId = interaction.customId.replace('comprar_', '');
      const produto = produtos.find(p => p.id === produtoId);

      if (!produto) return;

      if (produto.estoque <= 0) {
        const estoqueEmbed = new EmbedBuilder()
          .setTitle('‚ùå **Produto Esgotado**')
          .setDescription('**Desculpe! Esta moeda est√° temporariamente esgotada.**\n\nTente novamente mais tarde.')
          .setColor(COLORS.danger)
          .setThumbnail(ICON_URL)
          .setFooter({ text: `üõí Loja Online | ${STORE_NAME}`, iconURL: ICON_URL })
          .setTimestamp();

        return interaction.reply({ embeds: [estoqueEmbed], flags: MessageFlags.Ephemeral });
      }

      const modal = new ModalBuilder()
        .setCustomId(`modal_${produto.id}`)
        .setTitle(`üçé Comprar ${produto.nome}`);

      const usernameInput = new TextInputBuilder()
        .setCustomId('roblox_username')
        .setLabel('üë§ Qual seu nome de usu√°rio no Roblox?')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('Digite seu username exato do Roblox')
        .setRequired(true)
        .setMaxLength(20)
        .setMinLength(3);

      const row = new ActionRowBuilder().addComponents(usernameInput);
      modal.addComponents(row);

      await interaction.showModal(modal);
    }
  });

  // Handle modal submissions for fruits
  client.on('interactionCreate', async (interaction) => {
    if (!interaction.isModalSubmit()) return;

    if (interaction.customId === 'copiar_pix') {
  await interaction.reply({
    content: 'üìã C√≥digo PIX copiado com sucesso:\n```' + pixCodeTemp[interaction.user.id] + '```',
    ephemeral: true
  });
}


    if (interaction.customId.startsWith('modal_fruta')) {
      const produtoId = interaction.customId.replace('modal_', '');
      const produto = produtos.find(p => p.id === produtoId);
      const username = interaction.fields.getTextInputValue('roblox_username');

      if (!produto) return;

      await interaction.deferReply({ flags: MessageFlags.Ephemeral });

      // Start verification process
      await simulateRobloxVerification(interaction, username, produto);
    }
  });
}
